<!doctype html>
<meta charset="utf-8">
<title>SMS Spam Naive Bayes - Public Report</title>
<style>
 body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 20px; }
 h1, h2 { margin: 12px 0; }
 pre { background: #f7f7f7; padding: 12px; border-radius: 8px; white-space: pre-wrap; }
 table { border-collapse: collapse; width: 100%; }
 th, td { border: 1px solid #ddd; padding: 6px 8px; }
 th { background: #fafafa; }
 img { max-width: 100%; height: auto; }
</style>
<h1>SMS Spam Naive Bayes - Report (Public)</h1>
<h2>Metrics</h2>
<ul>
  <li>Accuracy: 0.9785</li>
  <li>Precision (macro): 0.9429</li>
  <li>Recall (macro): 0.9677</li>
  <li>F1 (macro): 0.9548</li>
</ul>
<h2>Confusion Matrix</h2>
<img src="confusion_matrix.png" alt="confusion matrix">
<h2>Predicted Class Counts (10 Messages)</h2>
<img src="messages_pred_counts.png" alt="pred counts">
<h2>Predictions for 10 Messages</h2>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>id</th>
      <th>message</th>
      <th>prediction</th>
      <th>P_ham</th>
      <th>P_spam</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>how are you .fine, thank you and you?</td>
      <td>ham</td>
      <td>9.935948e-01</td>
      <td>0.006405</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Good News, You've won a big prize, please call 00861888888888 for more information</td>
      <td>spam</td>
      <td>4.978990e-03</td>
      <td>0.995021</td>
    </tr>
    <tr>
      <td>3</td>
      <td>are you ok</td>
      <td>ham</td>
      <td>8.658290e-01</td>
      <td>0.134171</td>
    </tr>
    <tr>
      <td>4</td>
      <td>not at all</td>
      <td>ham</td>
      <td>8.658290e-01</td>
      <td>0.134171</td>
    </tr>
    <tr>
      <td>5</td>
      <td>WINNER, You have won a 1 week FREE membership in our £100,000 Prize Jackpot!</td>
      <td>spam</td>
      <td>4.740179e-09</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <td>6</td>
      <td>winner winner chicken dinner</td>
      <td>spam</td>
      <td>2.351027e-01</td>
      <td>0.764897</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Congratulations on your invitation to join Honor Society!</td>
      <td>spam</td>
      <td>5.293277e-02</td>
      <td>0.947067</td>
    </tr>
    <tr>
      <td>8</td>
      <td>I love you guys.</td>
      <td>ham</td>
      <td>9.959454e-01</td>
      <td>0.004055</td>
    </tr>
    <tr>
      <td>9</td>
      <td>Extra large discount, three bamboo rats and three 10 yuan</td>
      <td>spam</td>
      <td>8.949609e-02</td>
      <td>0.910504</td>
    </tr>
    <tr>
      <td>10</td>
      <td>good good study day day up</td>
      <td>ham</td>
      <td>9.987550e-01</td>
      <td>0.001245</td>
    </tr>
  </tbody>
</table>
<h2>Source Code (一键成片.py)</h2>
<pre># -*- coding: utf-8 -*-
# 朴素贝叶斯短信垃圾分类：训练+评估+10条预测+报告
# 外网直连版：自动尝试用 cloudflared 暴露公网地址，并生成公网二维码
import os, re, string, math, socket, html as html_lib, time, threading, subprocess, sys
import numpy as np
import pandas as pd
from collections import defaultdict
from sklearn.model_selection import train_test_split
from sklearn.metrics import (accuracy_score, precision_score, recall_score,
                             f1_score, confusion_matrix, classification_report)

# ---- 无GUI后端，避免 _tkinter/TclError ----
import matplotlib
matplotlib.use(&quot;Agg&quot;)
import matplotlib.pyplot as plt

# ---- 二维码 ----
try:
    import qrcode
except ImportError:
    print(&quot;缺少依赖：请先安装二维码库 → python -m pip install \&quot;qrcode[pil]\&quot;&quot;)
    sys.exit(1)

# ===================== 1) 数据读取 =====================
def load_stopwords(path=&#x27;stopwords.txt&#x27;):
    with open(path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f:
        return set(w.strip() for w in f if w.strip())

stopwords = load_stopwords(&#x27;stopwords.txt&#x27;)
data = pd.read_csv(&#x27;SMSSpamCollection.txt&#x27;, sep=&#x27;\t&#x27;, header=None, names=[&#x27;labels&#x27;,&#x27;messages&#x27;])
X, y = data[&#x27;messages&#x27;], data[&#x27;labels&#x27;]
target_names = [&#x27;ham&#x27;,&#x27;spam&#x27;]
print(&quot;数据前5行：\n&quot;, data.head())

# ===================== 2) 预处理（返回词列表） =====================
_punc_re = re.compile(f&#x27;[{re.escape(string.punctuation)}]&#x27;)

def preprocess(text: str):
    text = text.lower()
    text = _punc_re.sub(&#x27; &#x27;, text)
    return [w for w in text.split() if w not in stopwords]

# ===================== 3) 自实现多项式朴素贝叶斯 =====================
class NaiveBayesClassifier:
    def __init__(self, alpha: float = 1.0):
        self.alpha = float(alpha)
        self.vocabulary = set()
        self.class_total = defaultdict(int)                 # 每类文档数
        self.word_total = defaultdict(int)                  # 每类词频总和
        self.word_given_class = defaultdict(lambda: defaultdict(int))  # 类-&gt;词-&gt;频
        self.classes_, self.vocab_size, self.log_prior_ = [], 0, {}

    def fit(self, X_iter, y_iter):
        for text, label in zip(X_iter, y_iter):
            words = preprocess(text)
            self.class_total[label] += 1
            for w in words:
                self.vocabulary.add(w)
                self.word_given_class[label][w] += 1
                self.word_total[label] += 1
        self.classes_ = list(self.class_total.keys())
        self.vocab_size = len(self.vocabulary)
        N = sum(self.class_total.values())
        self.log_prior_ = {c: math.log(self.class_total[c] / N) for c in self.classes_}
        return self

    def _log_likelihood_sum(self, tokens, c: str) -&gt; float:
        total_c = self.word_total[c]
        denom = total_c + self.alpha * self.vocab_size
        s = 0.0
        for w in tokens:
            num = self.word_given_class[c].get(w, 0) + self.alpha
            s += math.log(num / denom)
        return s

    def predict_log_proba(self, X_iter):
        if isinstance(X_iter, str):
            X_iter = [X_iter]
        out = []
        for text in X_iter:
            toks = preprocess(text)
            scores = [self.log_prior_[c] + self._log_likelihood_sum(toks, c) for c in self.classes_]
            m = max(scores); exps = [math.exp(s - m) for s in scores]; Z = sum(exps)
            out.append([math.log(e / Z) for e in exps])
        return np.array(out)

    def predict_proba(self, X_iter):
        return np.exp(self.predict_log_proba(X_iter))

    def predict(self, X_iter):
        if isinstance(X_iter, str):
            X_iter = [X_iter]
        logp = self.predict_log_proba(X_iter)
        idx = logp.argmax(axis=1)
        return np.array([self.classes_[i] for i in idx])

# ===================== 4) 训练与评估 =====================
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)
clf = NaiveBayesClassifier(alpha=1.0).fit(X_train, y_train)
pred_test = clf.predict(X_test)

y_true = np.asarray(y_test); y_pred = np.asarray(pred_test)
label_order = [&#x27;ham&#x27;,&#x27;spam&#x27;]
acc = accuracy_score(y_true, y_pred)
prec_macro = precision_score(y_true, y_pred, labels=label_order, average=&#x27;macro&#x27;, zero_division=0)
recall_macro = recall_score(y_true, y_pred, labels=label_order, average=&#x27;macro&#x27;, zero_division=0)
f1_macro = f1_score(y_true, y_pred, labels=label_order, average=&#x27;macro&#x27;, zero_division=0)
cm = confusion_matrix(y_true, y_pred, labels=label_order)

print(f&quot;\nAccuracy: {acc:.4f}&quot;)
print(f&quot;Precision (macro): {prec_macro:.4f}  Recall (macro): {recall_macro:.4f}  F1 (macro): {f1_macro:.4f}&quot;)
print(&#x27;\nConfusion Matrix (rows=true, cols=pred) order=&#x27;, label_order)
print(cm)
print(&#x27;\nClassification Report:&#x27;)
print(classification_report(y_true, y_pred, labels=label_order, target_names=label_order, digits=4, zero_division=0))

def save_confusion_matrix(cm, labels, filename):
    plt.figure(figsize=(4.8, 4.2))
    plt.imshow(cm, cmap=&#x27;Blues&#x27;)
    plt.title(&#x27;Confusion Matrix&#x27;); plt.xlabel(&#x27;Predicted&#x27;); plt.ylabel(&#x27;True&#x27;)
    plt.xticks(range(len(labels)), labels); plt.yticks(range(len(labels)), labels)
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            plt.text(j, i, int(cm[i, j]), ha=&#x27;center&#x27;, va=&#x27;center&#x27;)
    plt.tight_layout(); plt.savefig(filename, dpi=200, bbox_inches=&#x27;tight&#x27;); plt.close()
    print(&quot;混淆矩阵已保存：&quot;, os.path.abspath(filename))

save_confusion_matrix(cm, label_order, &quot;confusion_matrix.png&quot;)

# ===================== 5) 任务：预测给定10段文本 =====================
messages = [
    &#x27;how are you .fine, thank you and you?&#x27;,
    &quot;Good News, You&#x27;ve won a big prize, please call 00861888888888 for more information&quot;,
    &#x27;are you ok&#x27;,
    &#x27;not at all&#x27;,
    &#x27;WINNER, You have won a 1 week FREE membership in our £100,000 Prize Jackpot!&#x27;,
    &#x27;winner winner chicken dinner&#x27;,
    &#x27;Congratulations on your invitation to join Honor Society!&#x27;,
    &#x27;I love you guys.&#x27;,
    &#x27;Extra large discount, three bamboo rats and three 10 yuan&#x27;,
    &#x27;good good study day day up&#x27;
]
pred_msgs = clf.predict(messages)
proba_msgs = clf.predict_proba(messages)
cls2idx = {c: i for i, c in enumerate(clf.classes_)}
p_ham = proba_msgs[:, cls2idx[&#x27;ham&#x27;]]; p_spam = proba_msgs[:, cls2idx[&#x27;spam&#x27;]]

print(&quot;\n=== 给定10段文本的预测结果 ===&quot;)
for i, (msg, lab, ph, ps) in enumerate(zip(messages, pred_msgs, p_ham, p_spam), start=1):
    print(f&quot;{i:02d}. [{lab}]  P(ham)={ph:.3f}  P(spam)={ps:.3f}  | {msg}&quot;)

df_out = pd.DataFrame({
    &#x27;id&#x27;: range(1, len(messages)+1),
    &#x27;message&#x27;: messages,
    &#x27;prediction&#x27;: pred_msgs,
    &#x27;P_ham&#x27;: p_ham,
    &#x27;P_spam&#x27;: p_spam
})
csv_path = &quot;messages_predictions.csv&quot;
df_out.to_csv(csv_path, index=False, encoding=&#x27;utf-8&#x27;)
print(&quot;\n10段文本预测已保存：&quot;, os.path.abspath(csv_path))

def save_counts_bar(preds, filename):
    counts = pd.Series(preds).value_counts().reindex([&#x27;ham&#x27;,&#x27;spam&#x27;]).fillna(0)
    plt.figure(figsize=(4.8, 3.0))
    plt.bar(counts.index, counts.values)
    for x, v in zip(counts.index, counts.values):
        plt.text(x, v + 0.05, int(v), ha=&#x27;center&#x27;)
    plt.title(&#x27;Predicted Class Counts for 10 Messages&#x27;); plt.ylabel(&#x27;Count&#x27;)
    plt.tight_layout(); plt.savefig(filename, dpi=200, bbox_inches=&#x27;tight&#x27;); plt.close()
    print(&quot;10段文本类别计数图已保存：&quot;, os.path.abspath(filename))

save_counts_bar(pred_msgs, &quot;messages_pred_counts.png&quot;)

# ===================== 6) 生成网页报告 =====================
def get_local_ip(default=&#x27;127.0.0.1&#x27;):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect((&#x27;8.8.8.8&#x27;, 80)); ip = s.getsockname()[0]
    except Exception:
        ip = default
    finally:
        s.close()
    return ip

try:
    SRC_PATH = os.path.abspath(__file__)
    code_text = open(SRC_PATH, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;).read()
except Exception:
    SRC_PATH = &#x27;(unknown)&#x27;; code_text = &#x27;# 源代码读取失败&#x27;

code_html = html_lib.escape(code_text)
table_html = df_out.to_html(index=False, escape=True)

html = f&quot;&quot;&quot;&lt;!doctype html&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;SMS Spam Naive Bayes - Public Report&lt;/title&gt;
&lt;style&gt;
 body {{ font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial; margin: 20px; }}
 h1, h2 {{ margin: 12px 0; }}
 pre {{ background: #f7f7f7; padding: 12px; border-radius: 8px; white-space: pre-wrap; }}
 table {{ border-collapse: collapse; width: 100%; }}
 th, td {{ border: 1px solid #ddd; padding: 6px 8px; }}
 th {{ background: #fafafa; }}
 img {{ max-width: 100%; height: auto; }}
&lt;/style&gt;
&lt;h1&gt;SMS Spam Naive Bayes - Report (Public)&lt;/h1&gt;
&lt;h2&gt;Metrics&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Accuracy: {acc:.4f}&lt;/li&gt;
  &lt;li&gt;Precision (macro): {prec_macro:.4f}&lt;/li&gt;
  &lt;li&gt;Recall (macro): {recall_macro:.4f}&lt;/li&gt;
  &lt;li&gt;F1 (macro): {f1_macro:.4f}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Confusion Matrix&lt;/h2&gt;
&lt;img src=&quot;confusion_matrix.png&quot; alt=&quot;confusion matrix&quot;&gt;
&lt;h2&gt;Predicted Class Counts (10 Messages)&lt;/h2&gt;
&lt;img src=&quot;messages_pred_counts.png&quot; alt=&quot;pred counts&quot;&gt;
&lt;h2&gt;Predictions for 10 Messages&lt;/h2&gt;
{table_html}
&lt;h2&gt;Source Code ({os.path.basename(SRC_PATH)})&lt;/h2&gt;
&lt;pre&gt;{code_html}&lt;/pre&gt;
&quot;&quot;&quot;
open(&quot;index.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;).write(html)
print(&quot;报告网页已生成：&quot;, os.path.abspath(&quot;index.html&quot;))

# ===================== 7) 启动本地HTTP + 自动尝试开公网隧道 =====================
from http.server import HTTPServer, SimpleHTTPRequestHandler

class QuietHandler(SimpleHTTPRequestHandler):
    def log_message(self, fmt, *args):  # 静默日志
        pass

def find_free_port(start=8000, tries=50):
    port = start
    for _ in range(tries):
        try:
            srv = HTTPServer((&quot;&quot;, port), QuietHandler)
            return srv, port
        except OSError:
            port += 1
    raise RuntimeError(&quot;没有找到可用端口&quot;)

BASE_DIR = os.path.dirname(os.path.abspath(__file__)) if &#x27;__file__&#x27; in globals() else os.getcwd()
os.chdir(BASE_DIR)
httpd, PORT = find_free_port(8000)
LOCAL_IP = get_local_ip()
local_url = f&quot;http://{LOCAL_IP}:{PORT}/index.html&quot;

def start_server():
    print(f&quot;\n本地服务已启动：{local_url}&quot;)
    httpd.serve_forever()

server_thread = threading.Thread(target=start_server, daemon=True)
server_thread.start()

# ---- 尝试启动 cloudflared quick tunnel，解析公网URL ----
public_url = None
def start_cloudflared(port: int, timeout_sec: int = 25):
    try:
        # Windows 上可直接调用 cloudflared；若不在 PATH，会触发 FileNotFoundError
        proc = subprocess.Popen(
            [&quot;cloudflared&quot;, &quot;tunnel&quot;, &quot;--url&quot;, f&quot;http://localhost:{port}&quot;],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding=&quot;utf-8&quot;
        )
    except FileNotFoundError:
        print(&quot;\n未检测到 cloudflared，可通过以下方式安装其一：&quot;)
        print(&quot;  1) winget install Cloudflare.Cloudflared&quot;)
        print(&quot;  2) 或下载 cloudflared.exe 并加入 PATH&quot;)
        return None, None

    url = None
    deadline = time.time() + timeout_sec
    pattern = re.compile(r&quot;https://[-a-zA-Z0-9.]*trycloudflare\.com&quot;)
    lines = []
    while time.time() &lt; deadline:
        line = proc.stdout.readline()
        if not line:
            time.sleep(0.1); continue
        lines.append(line)
        m = pattern.search(line)
        if m:
            url = m.group(0)
            break
    if url:
        print(&quot;\nCloudflare Tunnel 已建立：&quot;, url)
        return proc, url
    else:
        print(&quot;\n未能在超时时间内获得公网URL。你可以手动在终端运行：&quot;)
        print(f&quot;  cloudflared tunnel --url http://localhost:{port}&quot;)
        return proc, None

cf_proc, public_url = start_cloudflared(PORT)

# ---- 生成二维码 ----
def make_qr(url, filename):
    img = qrcode.make(url); img.save(filename)
    print(f&quot;二维码已保存：{os.path.abspath(filename)}&quot;)
    print(&quot;扫码地址：&quot;, url)

# 优先公网；如果没有公网，则回退本地局域网地址
if public_url:
    make_qr(public_url, &quot;report_public_qr.png&quot;)
else:
    make_qr(local_url, &quot;report_local_qr.png&quot;)
    print(&quot;\n提示：上面的二维码只有在同一网络下可访问。&quot;
          &quot;若要公网访问，请安装 cloudflared 并重新运行脚本。&quot;)

print(&quot;\n按回车键停止服务器并退出...&quot;)
try:
    input()
finally:
    try:
        if cf_proc and cf_proc.poll() is None:
            cf_proc.terminate()
    except Exception:
        pass
    try:
        httpd.shutdown()
    except Exception:
        pass
</pre>
